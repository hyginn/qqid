% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uu2qq.R
\name{uu2qq}
\alias{uu2qq}
\title{uu2qq.}
\usage{
uu2qq(uu)
}
\arguments{
\item{uu}{(character) a vector of UUIDs}
}
\value{
(character)  a vector of QQIDs
}
\description{
\code{uu2qq} converts a vector of UUIDs to QQIDs.
}
\section{UUIDs and QQIDs}{
 UUIDs are specially formatted 128 bit numbers.
  Randomly chosen UUIDs have a collision probability that is small enough to
  make them useful as (practically) unique identifiers in applications where
  centralized management of IDs is not feasible or not desireable. However
  since they are long strings that chiefly consist of hexadecimal numbers,
  they are hard to distingiush by eye and that creates difficulties for
  development or debugging with structured data, or for curation of UUID
  tagged information. The \code{qqid} package provides tools to convert the
  leading 5 hexadecimal digits to two "Q-words", and the remainder to a
  string in a Base 64 encoding. The "Q-words" - the letter Q evokes the word
  "cue" i.e. a hint or mnemonic - define a unique and invertible mapping to
  the integers (0, 1023), i.e. all numbers that can be encoded with 10 bits.
  Thus two Q-words can encode 20 bits, or 5 hexadecimal letters:\cr
\code{         [0-9a-f]    [0-9a-f]    [0-9a-f]    [0-9a-f]    [0-9a-f]  }\cr
\code{  hex:  |--0x[1]--| |--0x[2]--| |--0x[3]--| |--0x[4]--| |--0x[5]--|}\cr
\code{  bit:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}\cr
\code{  int:  |----------int[1]-----------| |----------int[2]-----------|}\cr
\code{                  (0, 1023)                     (0, 1023)          }\cr
\code{  Q:          (aims, ..., zone)             (aims, ..., zone)      }\cr
}

\section{Process}{
 To convert a UUID to a QQID, the first five hexadecimal
  letters are converted to two ten bit numbers, these two numbers are
  interpreted as an index into the 1024-element Q-Word vector. The QQID has
  the two vectors as a head, and the Base 64 encoded digits 6 to 32 of the
  UUID as its tail. Since the mapping is fully reversible, QQIDs have exactly
  the same statistical properties as UUIDs. For details on QQID format see
  \code{\link{isValidQQID}}.
}

\section{Endianness}{
 qqid package uses its own functions to convert to and
  from bits and is not affected by big-endian vs. little-endian processor
  architectore.
}

\examples{
# Convert three example UUIDs and one NA to the corresponding QQIDs
uu2qq( c(UUIDexample(c(1, 3, 5)), NA) )

}
\seealso{
\code{\link{qq2uu}} to convert a vector of QQIDs to UUIDs.
}
\author{
\href{https://orcid.org/0000-0002-1134-6758}{Boris Steipe} (aut)
}
