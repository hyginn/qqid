% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qq2uu.R
\name{qq2uu}
\alias{qq2uu}
\title{qq2uu.}
\usage{
qq2uu(qq)
}
\arguments{
\item{qq}{(character) a vector of QQIDs}
}
\value{
(character)  a vector of UUIDs
}
\description{
\code{qq2uu} converts a vector of QQIDs to UUIDs.
}
\details{
Details.
}
\section{QQIDs}{
 QQIDs are specially formatted UUIDs. See
\code{\link{uu2qq}} for the the motivation of mapping UUIDs to QQIDs and
details on how QQIDs are structured. This function reveses the mapping
exactly to recover the original UUID.
}

\section{Process}{
 To convert a QQID to a UUID, the two "Q-words" that head
the QQID are mapped to their index in the 1024-element Q-word vector (cf.
\code{\link{qMap}}), and the indices are converted to two ten bit numbers.
These twenty bits are expressed as a five-digit hexadecimal number which
replaces the two Q-words to recover the UUID. For details on UUID format see
\code{\link{isValidUUID}}.
}

\section{Endianness}{
 The conversion of Q-words to hex-numbers assumes a
little-endian byte order. This means the mapping may not be reversible
between different processor architectures. Nearly all platforms on which
this code is likely to run are little-endian. In addition, a swapped byte
order will still yield valid and equally random UUIDs. If this issue is of
concern, check your system with the example code provided here. You can
also check your architecture with \code{.Platform$endian}.
}

\examples{
# Convert three example QQIDs and one NA to the corresponding UUIDs
qq2uu( c(QQIDexample(c(1, 3, 5)), NA) )

# This expression is TRUE and correct if the code
# is executed on a little-endian processor architecture.
qq2uu( QQIDexample(1) ) == UUIDexample(1)

}
\seealso{
\code{\link{uu2qq}} to convert a vector of UUIDs to QQIDs.
}
\author{
\href{https://orcid.org/0000-0002-1134-6758}{Boris Steipe} (aut)
}
